SELECT * FROM customer;
SELECT * FROM driver;
SELECT * FROM cab;
SELECT * FROM booking;
SELECT * FROM trip_details;
SELECT * FROM payment;
SELECT * FROM feedback;

-- Customer and Booking Analysis 
-- 1. Identify customers who have completed the most bookings. What insights can you draw about their behavior?
SELECT
	c.customer_name,
	COUNT(b.booking_id) AS no_of_bookings
FROM 
	booking b
INNER JOIN 
	customer c ON b.customer_id = c.customer_id
GROUP BY 
	c.customer_name
HAVING COUNT(b.booking_id) = (SELECT 
								MAX(no_of_bookings) 
							FROM(
								SELECT 
									COUNT(b.booking_id) AS no_of_bookings
								FROM 
									booking b
								INNER JOIN 
									customer c ON b.customer_id = c.customer_id
								GROUP BY 
									c.customer_name));

-- 2. Find customers who have canceled more than 30% of their total bookings. What could be the reason for frequent cancellations? 
SELECT 
	c.customer_id,
	c.customer_name,
	COUNT(td.trip_id) AS total_trips,
	SUM(CASE WHEN td.trip_status = 'Cancelled' THEN 1 ELSE 0 END) AS cancelled_trips,
	ROUND(SUM(CASE WHEN td.trip_status = 'Cancelled' THEN 1 ELSE 0 END) * 100.0 / COUNT(td.trip_id), 2) AS cancel_percentage,
	(SELECT string_agg(fb.review, '; ' ORDER BY fb.review) FROM feedback fb WHERE fb.customer_id = c.customer_id LIMIT 1) AS all_reviews
FROM 
	customer c
INNER JOIN 
	booking b ON c.customer_id = b.customer_id
INNER JOIN 
	trip_details td ON td.booking_id = b.booking_id
GROUP BY 
	c.customer_id, c.customer_name
HAVING 
	SUM(CASE WHEN td.trip_status = 'Cancelled' THEN 1 ELSE 0 END) * 100.0 / COUNT(td.trip_id) > 30;

-- 3. Determine the busiest day of the week for bookings. How can the company optimize cab availability on peak days?
SELECT
	TO_CHAR(booking_date, 'DAY') AS day_of_week,
	COUNT(booking_id) AS no_of_bookings
FROM 
	booking
GROUP BY
	TO_CHAR(booking_date, 'DAY')
HAVING COUNT(booking_id) = (SELECT 
								MAX(no_of_bookings)
							FROM(
								SELECT
									COUNT(booking_id) AS no_of_bookings
								FROM 
									booking
								GROUP BY
								TO_CHAR(booking_date, 'DAY')));


-- Driver Performance & Efficiency 
-- 1. Identify drivers who have received an average rating below 3.0 in the past three months. What strategies can be implemented to improve their performance? 
SELECT
	d.driver_name,
	ROUND(AVG(fb.rating),2) AS average_rating
FROM
	driver d
INNER JOIN
	feedback fb ON fb.driver_id = d.driver_id
GROUP BY
	d.driver_name
HAVING
	ROUND(AVG(fb.rating),2) < 3
ORDER BY
	average_rating ASC;

-- 2. Find the top 5 drivers who have completed the longest trips in terms of distance. What does this say about their working patterns?
SELECT
	driver_ranking.driver_name,
	driver_ranking.distance_in_km,
	driver_ranking.cab_type,
	driver_ranking.distance_based_rank
FROM
	(SELECT
		d.driver_name,
		td.distance_in_km,
		cb.cab_type,
		DENSE_RANK() OVER(ORDER BY (td.distance_in_km) DESC) AS distance_based_rank
	FROM
		driver d
	INNER JOIN
		cab cb ON d.cab_id = cb.cab_id
	INNER JOIN
		booking b ON b.driver_id = d.driver_id
	INNER JOIN
		trip_details td ON td.booking_id = b.booking_id
	WHERE
		td.trip_status = 'Completed') AS driver_ranking
WHERE
	driver_ranking.distance_based_rank < 6;

-- distribution of cabs per rank
SELECT
	driver_ranking.cab_type,
	COUNT(driver_ranking.cab_type) AS no_of_cabs
FROM
	(SELECT
		d.driver_name,
		td.distance_in_km,
		cb.cab_type,
		DENSE_RANK() OVER(ORDER BY (td.distance_in_km) DESC) AS distance_based_rank
	FROM
		driver d
	INNER JOIN
		cab cb ON d.cab_id = cb.cab_id
	INNER JOIN
		booking b ON b.driver_id = d.driver_id
	INNER JOIN
		trip_details td ON td.booking_id = b.booking_id
	WHERE
		td.trip_status = 'Completed') AS driver_ranking
WHERE driver_ranking.distance_based_rank = 3
GROUP BY driver_ranking.cab_type;

-- 3. Identify drivers with a high percentage of canceled trips. Could this indicate driver unreliability? 
SELECT
	d.driver_id,
	d.driver_name,
	COUNT(td.trip_id) AS total_trips,
	SUM(CASE WHEN td.trip_status = 'Cancelled' THEN 1 ELSE 0 END) AS cancelled_trips,
	ROUND(SUM(CASE WHEN td.trip_status = 'Cancelled' THEN 1 ELSE 0 END) * 100.0 / COUNT(td.trip_id), 2) AS cancel_percentage,
	(SELECT string_agg(fb.review, '; ' ORDER BY fb.review) FROM feedback fb WHERE fb.driver_id = d.driver_id) AS all_reviews
FROM
	driver d
INNER JOIN 
	booking b ON d.driver_id = b.driver_id
INNER JOIN 
	trip_details td ON td.booking_id = b.booking_id
GROUP BY 
	d.driver_id,d.driver_name
ORDER BY
	cancel_percentage DESC;


-- Revenue & Business Metrics 
-- 1. Calculate the total revenue generated by completed bookings in the last 6 months. How has the revenue trend changed over time? 
-- 6 month combined
SELECT
	SUM(p.amount) AS total_revenue_completed_bookings_last_6_month
FROM
	payment p
INNER JOIN
	trip_details td ON td.payment_id = p.payment_id
INNER JOIN
	booking b ON b.booking_id = td.booking_id
WHERE
	td.trip_status = 'Completed'
	AND b.booking_date BETWEEN '2025-01-01' AND '2025-07-01';

-- per month
SELECT
	TO_CHAR(booking_date,'Month') AS month,
	SUM(p.amount) AS total_revenue
FROM
	payment p
INNER JOIN
	trip_details td ON td.payment_id = p.payment_id
INNER JOIN
	booking b ON b.booking_id = td.booking_id
WHERE
	td.trip_status = 'Completed'
	AND b.booking_date BETWEEN '2025-01-01' AND '2025-06-30 23:59:59'
GROUP BY
	TO_CHAR(booking_date,'Month');

-- 2. Identify the top 3 most frequently traveled routes based on PickupLocation and DropoffLocation. Should the company allocate more cabs to these routes?
SELECT
	route.pick_up_location,
	route.drop_off_location,
	route.frequency_of_route,
	route.route_rank
FROM
	(SELECT
		pick_up_location,
		drop_off_location,
		COUNT(trip_id) AS frequency_of_route,
		DENSE_RANK() OVER(ORDER BY COUNT(trip_id) DESC) AS route_rank
	FROM
		trip_details
	GROUP BY
		pick_up_location, drop_off_location) AS route
WHERE
	route.route_rank < 4;
	
-- 3. Determine if higher-rated drivers tend to complete more trips and earn higher fares. Is there a direct correlation between driver ratings and earnings?
SELECT
	d.driver_id,
	d.driver_name,
	COUNT(td.trip_id) AS total_trips,
	SUM(CASE WHEN td.trip_status = 'Completed' THEN 1 ELSE 0 END) AS completed_trips,
	SUM(CASE WHEN td.trip_status = 'Cancelled' THEN 1 ELSE 0 END) AS cancelled_trips,
	SUM(CASE WHEN td.trip_status = 'Completed' THEN p.amount ELSE 0 END) AS completed_trips_revenue,
	SUM(CASE WHEN td.trip_status = 'Cancelled' THEN p.amount ELSE 0 END) AS cancelled_trips_revenue,
	(SELECT cb.cab_type FROM cab cb WHERE cb.cab_id = d.cab_id) AS cab_name,
	(SELECT SUM(p.amount) FROM booking b JOIN trip_details td ON b.booking_id = td.booking_id JOIN payment p ON td.payment_id = p.payment_id WHERE b.driver_id = d.driver_id) AS potenttial_earnings,
	(SELECT ROUND(AVG(fb.rating),2) FROM feedback fb WHERE fb.driver_id = d.driver_id) AS avg_rating
FROM
	driver d
INNER JOIN 
	booking b ON d.driver_id = b.driver_id
INNER JOIN 
	trip_details td ON td.booking_id = b.booking_id
INNER JOIN 
	payment p ON p.payment_id = td.payment_id	
GROUP BY
	d.driver_id,d.driver_name
ORDER BY
	completed_trips DESC;


-- Operational Efficiency & Optimization 
-- 1. Analyze the average waiting time (difference between booking time and trip start time) for different pickup locations. How can this be optimized to reduce delays? 
SELECT
	td.pick_up_location,
	AVG(td.trip_start - b.booking_time) AS avg_waiting_time
FROM
	trip_details td
INNER JOIN
	booking b ON b.booking_id = td.booking_id
GROUP BY
	td.pick_up_location
ORDER BY
	avg_waiting_time DESC;

-- 2. Identify the most common reasons for trip cancellations from customer feedback. What actions can be taken to reduce cancellations? 
SELECT
	fb.review AS reasons,
	COUNT(fb.review) AS occurence
FROM
	feedback fb
INNER JOIN
	trip_details td ON td.feedback_id = fb.feedback_id
WHERE
	td.trip_status = 'Cancelled'
GROUP BY
	fb.review;
	
-- 3. Find out whether shorter trips (low-distance) contribute significantly to revenue. Should the company encourage more short-distance rides? 
SELECT
	CASE 
		WHEN td.distance_in_km <=10 THEN '<=10 km'
    	WHEN td.distance_in_km BETWEEN 11 AND 20 THEN '11-20 km'
    	WHEN td.distance_in_km BETWEEN 21 AND 30 THEN '21-30 km'
    	ELSE '>30 km'
	END AS distance_range,
	SUM(p.amount) AS total_revenue
FROM
	trip_details td
INNER JOIN
	payment p ON p.payment_id = td.payment_id
WHERE
	td.trip_status = 'Completed'
GROUP BY
	CASE 
		WHEN td.distance_in_km <=10 THEN '<=10 km'
    	WHEN td.distance_in_km BETWEEN 11 AND 20 THEN '11-20 km'
    	WHEN td.distance_in_km BETWEEN 21 AND 30 THEN '21-30 km'
    	ELSE '>30 km'
	END
ORDER BY
	total_revenue ASC;


-- Comparative & Predictive Analysis 
-- 1. Compare the revenue generated from 'Sedan' and 'SUV' cabs. Should the company invest more in a particular vehicle type? 
SELECT
	cb.cab_type,
	SUM(p.amount) AS revenue_per_vehicle
FROM
	cab cb
INNER JOIN
	driver d ON d.cab_id = cb.cab_id
INNER JOIN
	booking b ON b.driver_id = d.driver_id
INNER JOIN
	trip_details td ON td.booking_id = b.booking_id
INNER JOIN
	payment p ON p.payment_id = td.payment_id
WHERE
	cb.cab_type IN('Sedan','SUV')
	AND td.trip_status = 'Completed'
GROUP BY
	cb.cab_type;

-- 2. Predict which customers are likely to stop using the service based on their last booking date and frequency of rides. How can customer retention be improved?
SELECT
    c.customer_id,
    c.customer_name,
    COUNT(b.booking_id) AS total_bookings,
    MIN(b.booking_date) AS first_booking_date,
    MAX(b.booking_date) AS last_booking_date,
    '2025-07-11' - MAX(b.booking_date) AS days_since_last_booking,
    -- CASE
    --     WHEN COUNT(b.booking_id) > 1 THEN
    --         (MAX(b.booking_date) - MIN(b.booking_date))/(COUNT(b.booking_id) - 1)
    --     ELSE NULL
    -- END AS avg_days_between_bookings,
    CASE
        WHEN '2025-07-11' - MAX(b.booking_date) > 60 THEN 'At Risk'
        ELSE 'Active'
    END AS churn_risk
FROM
    customer c
INNER JOIN
    booking b ON b.customer_id = c.customer_id
GROUP BY
    c.customer_id, c.customer_name
ORDER BY
    total_bookings DESC;

-- 3. Analyze whether weekend bookings differ significantly from weekday bookings. Should the company introduce dynamic pricing based on demand?
SELECT
	CASE 
    	WHEN EXTRACT(DOW FROM booking_date) IN (0, 6) THEN 'Weekend'
    	ELSE 'Weekday'
	END AS day_type,
	COUNT(*) AS total_bookings
FROM 
	booking
GROUP BY 
	CASE 
    	WHEN EXTRACT(DOW FROM booking_date) IN (0, 6) THEN 'Weekend'
		ELSE 'Weekday'
	END
ORDER BY
	total_bookings DESC;

